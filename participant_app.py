"""Read-only participant view of repository evaluations.

This Flask app exposes a minimal interface for hackathon participants to
browse the analyses that were generated by the evaluator.

It re-uses the same SQLite database (analysis.db) created by webapp.py
and shows all analyses, ordered by their creation time (newest first),
with links to the full details page.
"""
from __future__ import annotations

import sqlite3
import time
from pathlib import Path
from typing import Any

import json
from flask import Flask, render_template, url_for

# Paths ---------------------------------------------------------------------
APP_DIR = Path(__file__).resolve().parent
DB_PATH = APP_DIR / "analysis.db"

# Flask setup ---------------------------------------------------------------
app = Flask(__name__)


def _init_db() -> None:
    """Create the analysis table if it doesn't yet exist (read-only apps need it for queries)."""
    with sqlite3.connect(DB_PATH) as conn:
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS analysis (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp INTEGER NOT NULL,
                repo_url TEXT NOT NULL,
                problem_statement TEXT,
                result_json TEXT NOT NULL
            )
            """
        )
        conn.commit()


_init_db()


@app.template_filter("datetimeformat")
def _dt_filter(value: int) -> str:  # pragma: no cover
    """Convert epoch seconds to YYYY-MM-DD HH:MM format."""
    return time.strftime("%Y-%m-%d %H:%M", time.localtime(value))


@app.route("/")
def index():  # type: ignore
    """List recent analyses (read-only)."""
    with sqlite3.connect(DB_PATH) as conn:
        conn.row_factory = sqlite3.Row
        rows = conn.execute(
            "SELECT id, timestamp, repo_url, "
            "json_extract(result_json, '$.overall_score') AS overall_score, "
            "json_extract(result_json, '$.scores.code_quality_readability.score') AS cqr, "
            "json_extract(result_json, '$.scores.functionality_completeness.score') AS fc, "
            "json_extract(result_json, '$.scores.efficiency_performance.score') AS ep, "
            "json_extract(result_json, '$.scores.error_handling_robustness.score') AS eh, "
            "json_extract(result_json, '$.scores.version_control_practices.score') AS vc, "
            "json_extract(result_json, '$.scores.technology_utilization.score') AS tu "
            "FROM analysis ORDER BY id DESC LIMIT 100"
        ).fetchall()
    analyses: list[dict[str, Any]] = [dict(r) for r in rows]
    return render_template("participant_index.html", analyses=analyses)


@app.route("/analysis/<int:analysis_id>")
def view_analysis(analysis_id: int):  # type: ignore
    """Show the full analysis details (read-only)."""
    with sqlite3.connect(DB_PATH) as conn:
        row = conn.execute(
            "SELECT repo_url, problem_statement, result_json FROM analysis WHERE id = ?",
            (analysis_id,),
        ).fetchone()
    if not row:
        return "Analysis not found", 404

    return render_template(
        "analysis.html",
        repo_url=row[0],
        problem_statement=row[1],
        result=json.loads(row[2]),
    )


if __name__ == "__main__":  # pragma: no cover
    app.run(debug=True, port=5001)
